<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Gráficos Combinados</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <style>
    body {
      font-family: sans-serif;
    }

    .label {
      font-size: 12px;
      alignment-baseline: middle;
    }

    .dot {
      fill: lightblue;
      stroke: black;
      stroke-width: 1px;
    }

    .line {
      stroke: gray;
      stroke-width: 2px;
    }

    .question-label {
      font-weight: bold;
      font-size: 13px;
    }

    /* SVG{background-color: aqua;} */
  </style>
</head>

<body>
  
  <svg id="grafico-combinado"></svg>

  <button onclick="downloadSVG('grafico-combinado')">Download SVG</button>

  <script>
    const datasets = [
      {
        selector: "#grafico-precisao",
        data: [{ Pergunta: 1, estrategia: "PSB_3D", media: 0.67, IC95_inferior: 0.21, IC95_superior: 0.94 }, { Pergunta: 1, estrategia: "Def", media: 1.0, IC95_inferior: 0.44, IC95_superior: 1.0 }, { Pergunta: 1, estrategia: "PSB_2.5D", media: 1.0, IC95_inferior: 0.44, IC95_superior: 1.0 }, { Pergunta: 2, estrategia: "PSB_3D", media: 0.67, IC95_inferior: 0.21, IC95_superior: 0.94 }, { Pergunta: 2, estrategia: "Def", media: 1.0, IC95_inferior: 0.44, IC95_superior: 1.0 }, { Pergunta: 2, estrategia: "PSB_2.5D", media: 0.67, IC95_inferior: 0.21, IC95_superior: 0.94 }, { Pergunta: 3, estrategia: "PSB_3D", media: 1.0, IC95_inferior: 0.44, IC95_superior: 1.0 }, { Pergunta: 3, estrategia: "Def", media: 1.0, IC95_inferior: 0.44, IC95_superior: 1.0 }, { Pergunta: 3, estrategia: "PSB_2.5D", media: 1.0, IC95_inferior: 0.44, IC95_superior: 1.0 }, { Pergunta: 4, estrategia: "PSB_3D", media: 0.06, IC95_inferior: 0.06, IC95_superior: 0.06 }, { Pergunta: 4, estrategia: "Def", media: 0.41, IC95_inferior: 0.41, IC95_superior: 0.42 }, { Pergunta: 4, estrategia: "PSB_2.5D", media: 0.09, IC95_inferior: 0.09, IC95_superior: 0.09 }, { Pergunta: 5, estrategia: "PSB_3D", media: 2.14, IC95_inferior: 2.12, IC95_superior: 2.15 }, { Pergunta: 5, estrategia: "Def", media: 0.42, IC95_inferior: 0.42, IC95_superior: 0.42 }, { Pergunta: 5, estrategia: "PSB_2.5D", media: 0.08, IC95_inferior: 0.05, IC95_superior: 0.1 }, { Pergunta: 6, estrategia: "PSB_3D", media: 0.15, IC95_inferior: 0.04, IC95_superior: 0.34 }, { Pergunta: 6, estrategia: "Def", media: 0.23, IC95_inferior: 0.05, IC95_superior: 0.51 }, { Pergunta: 6, estrategia: "PSB_2.5D", media: 0.34, IC95_inferior: 0.06, IC95_superior: 0.56 }, { Pergunta: 7, estrategia: "PSB_3D", media: 0.77, IC95_inferior: 0.0, IC95_superior: 2.32 }, { Pergunta: 7, estrategia: "Def", media: 0.06, IC95_inferior: 0.0, IC95_superior: 0.18 }, { Pergunta: 7, estrategia: "PSB_2.5D", media: 0.02, IC95_inferior: 0.0, IC95_superior: 0.05 }, { Pergunta: 8, estrategia: "PSB_3D", media: 1.0, IC95_inferior: 0.44, IC95_superior: 1.0 }, { Pergunta: 8, estrategia: "Def", media: 0.67, IC95_inferior: 0.21, IC95_superior: 0.94 }, { Pergunta: 8, estrategia: "PSB_2.5D", media: 0.67, IC95_inferior: 0.21, IC95_superior: 0.94 }]
        // insira aqui os dados de precisão
      },
      {
        selector: "#grafico-duracao",
        data: [{ Pergunta: 1, estrategia: "PSB_3D", media: 11.0, IC95_inferior: 11.0, IC95_superior: 11.0 }, { Pergunta: 1, estrategia: "Def", media: 9.0, IC95_inferior: 9.0, IC95_superior: 9.0 }, { Pergunta: 1, estrategia: "PSB_2.5D", media: 9.0, IC95_inferior: 9.0, IC95_superior: 9.0 }, { Pergunta: 2, estrategia: "PSB_3D", media: 9.0, IC95_inferior: 9.0, IC95_superior: 9.0 }, { Pergunta: 2, estrategia: "Def", media: 9.0, IC95_inferior: 9.0, IC95_superior: 9.0 }, { Pergunta: 2, estrategia: "PSB_2.5D", media: 6.0, IC95_inferior: 6.0, IC95_superior: 6.0 }, { Pergunta: 3, estrategia: "PSB_3D", media: 24.0, IC95_inferior: 24.0, IC95_superior: 24.0 }, { Pergunta: 3, estrategia: "Def", media: 20.0, IC95_inferior: 20.0, IC95_superior: 20.0 }, { Pergunta: 3, estrategia: "PSB_2.5D", media: 7.0, IC95_inferior: 7.0, IC95_superior: 7.0 }, { Pergunta: 4, estrategia: "PSB_3D", media: 7.0, IC95_inferior: 7.0, IC95_superior: 7.0 }, { Pergunta: 4, estrategia: "Def", media: 8.0, IC95_inferior: 8.0, IC95_superior: 8.0 }, { Pergunta: 4, estrategia: "PSB_2.5D", media: 8.0, IC95_inferior: 8.0, IC95_superior: 8.0 }, { Pergunta: 5, estrategia: "PSB_3D", media: 16.0, IC95_inferior: 16.0, IC95_superior: 16.0 }, { Pergunta: 5, estrategia: "Def", media: 12.0, IC95_inferior: 12.0, IC95_superior: 12.0 }, { Pergunta: 5, estrategia: "PSB_2.5D", media: 24.0, IC95_inferior: 24.0, IC95_superior: 24.0 }, { Pergunta: 6, estrategia: "PSB_3D", media: 10.0, IC95_inferior: 10.0, IC95_superior: 10.0 }, { Pergunta: 6, estrategia: "Def", media: 11.0, IC95_inferior: 11.0, IC95_superior: 11.0 }, { Pergunta: 6, estrategia: "PSB_2.5D", media: 7.0, IC95_inferior: 7.0, IC95_superior: 7.0 }, { Pergunta: 7, estrategia: "PSB_3D", media: 26.0, IC95_inferior: 26.0, IC95_superior: 26.0 }, { Pergunta: 7, estrategia: "Def", media: 19.0, IC95_inferior: 19.0, IC95_superior: 19.0 }, { Pergunta: 7, estrategia: "PSB_2.5D", media: 30.0, IC95_inferior: 30.0, IC95_superior: 30.0 }, { Pergunta: 8, estrategia: "PSB_3D", media: 16.0, IC95_inferior: 16.0, IC95_superior: 16.0 }, { Pergunta: 8, estrategia: "Def", media: 9.0, IC95_inferior: 9.0, IC95_superior: 9.0 }, { Pergunta: 8, estrategia: "PSB_2.5D", media: 10.0, IC95_inferior: 10.0, IC95_superior: 10.0 }]

        // insira aqui os dados de duração
      }
    ];

    // Definir um mapeamento de cores para cada estratégia
    const estrategiaColors = {
      "PSB_3D": "#436ad0ff",      // Rosa
      "Def": "#9c6b4eff",         // Azul
      "PSB_2.5D": "#6cc5b0ff"     // Turquesa
    };

    const svgWidth = 1150;
    const svgHeight = 725;
    const svg = d3.select("#grafico-combinado")
      .attr("width", svgWidth)
      .attr("height", svgHeight);

    const offsets = {
      "#grafico-precisao": 0,
      "#grafico-duracao": 770
    };

    datasets.forEach(({ selector, data }) => {
      const offsetX = offsets[selector];
      if (selector === "#grafico-precisao") {
        renderGrafico1(svg, data, offsetX);
      } else if (selector === "#grafico-duracao") {
        renderGrafico2(svg, data, offsetX);
      }
    });


    function renderGrafico1(svg, rawData, offsetX) {
      const controlewidth = 280;
      const margin = { top: 30, right: 40, bottom: 20, left: controlewidth };
      const width = 670 - margin.left - margin.right;
      console.log(width)
      const rowHeight = 27;
      const height = rowHeight * rawData.length + 100;

      const posstrategy = -controlewidth * 0.83;
      const posestimate = -controlewidth * 0.48;

      const g = svg.append("g").attr("transform", `translate(${offsetX + margin.left},${margin.top})`);


      g.append("line")
        .attr("x1", -controlewidth)
        .attr("x2", 0)
        .attr("y1", -5)
        .attr("y2", -5)
        .attr("stroke", "black")
        .attr("stroke-width", 3);

      g.append("text").attr("x", -controlewidth).attr("y", -15).text("Task").attr("font-weight", "bold");
      g.append("text").attr("x", posstrategy).attr("y", -15).text("Strategy").attr("font-weight", "bold");
      g.append("text").attr("x", posestimate).attr("y", -15).text("Estimate (95% CI)").attr("font-weight", "bold");

      const x = d3.scaleLinear()
        .domain([
          d3.min(rawData, d => d.IC95_inferior) - 0.1,
          d3.max(rawData, d => d.IC95_superior) + 0.1
        ])
        .range([0, width]);

      const xCenter = (d3.min(rawData, d => d.IC95_inferior) + d3.max(rawData, d => d.IC95_superior)) / 2;

      g.append("text")
        .attr("x", x(xCenter))
        .attr("y", 690)
        .text("Error")
        .attr("font-weight", "bold")
        .attr("text-anchor", "middle");

      const y = d3.scaleBand()
        .domain(rawData.map((_, i) => i))
        .range([0, rowHeight * rawData.length])
        .padding(0.2);

      g.append("g")
        .attr("transform", `translate(0,${rowHeight * rawData.length})`)
        .call(d3.axisBottom(x).ticks(5)).selectAll("text").style("font-size", "11pt");


      // Adiciona as linhas de intervalo de confiança
      g.selectAll(".line")
        .data(rawData)
        .enter()
        .append("line")
        .attr("class", "line")
        .attr("x1", d => x(d.IC95_inferior))
        .attr("x2", d => x(d.IC95_superior))
        .attr("y1", (d, i) => y(i) + y.bandwidth() / 2)
        .attr("y2", (d, i) => y(i) + y.bandwidth() / 2)
        .style("stroke", d => estrategiaColors[d.estrategia])
        .style("stroke-width", "2px");   // Garante a largura

      // Adiciona os pontos médios
      g.selectAll(".dot")
        .data(rawData)
        .enter()
        .append("circle")
        .attr("class", "dot")
        .attr("cx", d => x(d.media))
        .attr("cy", (d, i) => y(i) + y.bandwidth() / 2)
        .attr("r", 5)
        .style("fill", d => estrategiaColors[d.estrategia])
        .style("stroke", "none")
        .style("stroke-width", "1px");


      g.selectAll(".estrategia-label")
        .data(rawData)
        .enter()
        .append("text")
        .attr("x", posstrategy)
        .attr("y", (d, i) => y(i) + y.bandwidth() / 2 + 3)
        .style("fill", d => estrategiaColors[d.estrategia] || "lightblue")
        .text(d => d.estrategia);

      g.selectAll(".valor-label")
        .data(rawData)
        .enter()
        .append("text")
        .attr("x", posestimate)
        .attr("y", (d, i) => y(i) + y.bandwidth() / 2 + 3)
        .style("fill", d => estrategiaColors[d.estrategia] || "lightblue")

        .text(d => `${d.media.toFixed(2)} (${d.IC95_inferior.toFixed(2)} to ${d.IC95_superior.toFixed(2)})`);

      const perguntasUnicas = [...new Set(rawData.map(d => d.Pergunta))];
      perguntasUnicas.forEach((pergunta, idx) => {
        const indices = rawData.map((d, i) => ({ i, pergunta: d.Pergunta }))
          .filter(d => d.pergunta === pergunta)
          .map(d => d.i);

        const perguntaData = rawData.filter(d => d.Pergunta === pergunta);

        // Adiciona retângulos de fundo cinza alternados
        g.selectAll(`.background-rect-${pergunta}`)
          .data(perguntaData)
          .enter()
          .insert("rect", ":first-child") // Insere antes do primeiro elemento filho
          .attr("x", -controlewidth)
          .attr("y", (d, i) => y(indices[i]) - 6)
          .attr("width", svgWidth)
          .attr("height", rowHeight)
          .attr("fill", idx % 2 === 0 ? "#c0c0c0" : "white")
          .attr("opacity", 0.3);

        const yMean = d3.mean(indices, i => y(i) + y.bandwidth() / 2);

        g.append("text")
          .attr("x", -(controlewidth * 0.967))
          .attr("y", yMean + 3)
          .attr("text-anchor", "start")
          .text(pergunta);

        // if (idx < perguntasUnicas.length - 1) {
        //   const lastIndex = indices[indices.length - 1];
        //   g.append("line")
        //     .attr("x1", -controlewidth)
        //     .attr("y1", y(lastIndex) + y.bandwidth())
        //     .attr("y2", y(lastIndex) + y.bandwidth())
        //     .attr("stroke", "gray")
        //     .attr("stroke-width", 1);
        // }
      });
    }

    function renderGrafico2(svg, rawData, offsetX) {
      const controlewidth = 135;
      // left controla o gap
      const margin = { top: 30, right: 40, bottom: 20, left: 20 };
      const width = 410 - margin.left - margin.right;
      console.log(width)
      const rowHeight = 27;

      const g = svg.append("g").attr("transform", `translate(${offsetX + margin.left},${margin.top})`);

      g.append("line")
        .attr("x1", -controlewidth)
        .attr("x2", 0)
        .attr("y1", -5)
        .attr("y2", -5)
        .attr("stroke", "black")
        .attr("stroke-width", 3);

      g.append("text")
        .attr("x", -controlewidth)
        .attr("y", -15)
        .text("Estimate (95% CI)")
        .attr("font-weight", "bold");

      const x = d3.scaleLinear()
        .domain([
          d3.min(rawData, d => d.IC95_inferior) - 1.0,
          d3.max(rawData, d => d.IC95_superior) + 0.1
        ])
        .range([0, width]);

      const xCenter = (d3.min(rawData, d => d.IC95_inferior) + d3.max(rawData, d => d.IC95_superior)) / 2;

      g.append("text")
        .attr("x", x(xCenter))
        .attr("y", 690)
        .text("Time (s)")
        .attr("font-weight", "bold")
        .attr("text-anchor", "middle");

      const y = d3.scaleBand()
        .domain(rawData.map((_, i) => i))
        .range([0, rowHeight * rawData.length])
        .padding(0.2);

      g.append("g")
        .attr("transform", `translate(0,${rowHeight * rawData.length})`)
        .call(d3.axisBottom(x).ticks(5)).selectAll("text").style("font-size", "11pt");

      // Adiciona as linhas de intervalo de confiança
      g.selectAll(".line")
        .data(rawData)
        .enter()
        .append("line")
        .attr("class", "line")
        .attr("x1", d => x(d.IC95_inferior))
        .attr("x2", d => x(d.IC95_superior))
        .attr("y1", (d, i) => y(i) + y.bandwidth() / 2)
        .attr("y2", (d, i) => y(i) + y.bandwidth() / 2)
        .style("stroke", d => estrategiaColors[d.estrategia] || "gray")
        .style("stroke-width", "2px");   // Garante a largura

      // Adiciona os pontos médios
      g.selectAll(".dot")
        .data(rawData)
        .enter()
        .append("circle")
        .attr("class", "dot")
        .attr("cx", d => x(d.media))
        .attr("cy", (d, i) => y(i) + y.bandwidth() / 2)
        .attr("r", 5)
        .style("fill", d => estrategiaColors[d.estrategia] || "lightblue")
        .style("stroke", "none")
        .style("stroke-width", "1px");

      g.selectAll(".valor-label")
        .data(rawData)
        .enter()
        .append("text")
        .attr("x", -controlewidth)
        .style("fill", d => estrategiaColors[d.estrategia] || "lightblue")
        .attr("y", (d, i) => y(i) + y.bandwidth() / 2 + 3)
        .text(d => `${d.media.toFixed(1)} (${d.IC95_inferior.toFixed(1)} to ${d.IC95_superior.toFixed(1)})`);

      // const perguntasUnicas = [...new Set(rawData.map(d => d.Pergunta))];
      // perguntasUnicas.forEach((pergunta, idx) => {
      //   const indices = rawData.map((d, i) => ({ i, pergunta: d.Pergunta }))
      //     .filter(d => d.pergunta === pergunta)
      //     .map(d => d.i);

      //   if (idx < perguntasUnicas.length - 1) {
      //     const lastIndex = indices[indices.length - 1];
      //     g.append("line")
      //       .attr("x1", -controlewidth)
      //       .attr("y1", y(lastIndex) + y.bandwidth())
      //       .attr("y2", y(lastIndex) + y.bandwidth())
      //       .attr("stroke", "gray")
      //       .attr("stroke-width", 1);
      //   }
      // });
    }


    function downloadSVG(svgId) {
      const svgElement = document.getElementById(svgId);
      if (!svgElement) {
        console.error("SVG não encontrado");
        return;
      }

      const serializer = new XMLSerializer();
      const svgString = serializer.serializeToString(svgElement);
      const blob = new Blob([svgString], { type: "image/svg+xml" });
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = "download.svg";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }


  </script>
</body>

</html>